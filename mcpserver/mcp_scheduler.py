#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MCP调度器 - 负责MCP任务的调度和执行
基于博弈论设计，提供任务去重、并发控制、失败重试等功能
"""

import asyncio
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from system.config import config, logger

# 能力信息从注册中心获取，由上层管理


@dataclass
class MCPTask:
    """MCP任务数据结构"""
    id: str
    query: str
    tool_calls: List[Dict[str, Any]]
    session_id: Optional[str] = None
    request_id: Optional[str] = None
    callback_url: Optional[str] = None
    status: str = "queued"
    created_at: str = ""
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    retry_count: int = 0
    max_retries: int = 3

class MCPScheduler:
    """MCP调度器 - 负责任务调度和执行"""
    
    def __init__(self, mcp_manager=None):
        self.mcp_manager = mcp_manager
        self.active_tasks: Dict[str, MCPTask] = {}
        self.completed_tasks: Dict[str, MCPTask] = {}
        self.task_queue = asyncio.Queue()
        self.worker_tasks: List[asyncio.Task] = []
        self.max_concurrent = 10
        self.shutdown_event = asyncio.Event()
        
        # 启动工作线程
        self._start_workers()
    
    def _start_workers(self):
        """启动工作线程"""
        for i in range(self.max_concurrent):
            worker = asyncio.create_task(self._worker(f"worker-{i}"))
            self.worker_tasks.append(worker)
    
    async def _worker(self, worker_name: str):
        """工作线程"""
        while not self.shutdown_event.is_set():
            try:
                # 等待任务或关闭信号
                task = await asyncio.wait_for(
                    self.task_queue.get(), 
                    timeout=1.0
                )
                
                if task is None:  # 关闭信号
                    break
                
                await self._execute_task(task)
                
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"工作线程 {worker_name} 执行任务失败: {e}")
        
        logger.info(f"MCP调度器工作线程 {worker_name} 关闭")
    
    async def _execute_task(self, task: MCPTask):
        """执行单个任务"""
        try:
            task.status = "running"
            task.started_at = datetime.utcnow().isoformat() + "Z"
            
            logger.info(f"开始执行MCP任务: {task.id} - {task.query[:50]}...")
            
            # 能力分析（已简化/可选）
            # 如需根据能力做路由，可在此从注册中心获取信息
                
            # 执行工具调用
            results = []
            for tool_call in task.tool_calls:
                try:
                    result = await self._execute_single_tool_call(tool_call)
                    results.append(result)
                except Exception as e:
                    logger.error(f"工具调用失败: {tool_call} - {e}")
                    results.append({
                        "tool": tool_call.get("tool_name", "unknown"),
                        "success": False,
                        "error": str(e)
                    })
            
            # 更新任务状态
            task.status = "completed"
            task.completed_at = datetime.utcnow().isoformat() + "Z"
            task.result = {
                "success": True,
                "results": results,
                "message": f"成功执行 {len(task.tool_calls)} 个工具调用"
            }
            
            logger.info(f"MCP任务完成: {task.id}")
            # 回调通知（可选）
            await self._maybe_callback(task)
            
        except Exception as e:
            logger.error(f"MCP任务执行失败: {task.id} - {e}")
            task.status = "failed"
            task.completed_at = datetime.utcnow().isoformat() + "Z"
            task.error = str(e)
            task.result = {
                "success": False,
                "error": str(e),
                "message": f"任务执行失败: {str(e)}"
            }
            # 回调失败也尝试通知
            try:
                await self._maybe_callback(task)
            except Exception:
                pass
        
        finally:
            # 移动到已完成任务
            if task.id in self.active_tasks:
                del self.active_tasks[task.id]
            self.completed_tasks[task.id] = task

    async def _maybe_callback(self, task: MCPTask) -> None:
        """如果提供了callback_url，则POST回传任务结果"""
        if not task.callback_url:
            logger.debug(f"任务 {task.id} 没有设置callback_url，跳过回调")
            return
        try:
            import aiohttp
            import asyncio
            payload = {
                "task_id": task.id,
                "session_id": task.session_id,
                "success": task.result.get("success") if task.result else False,
                "result": task.result,
                "error": task.error,
                "completed_at": task.completed_at,
            }

            # 直接调用外部回调URL（通常是apiserver的tool_result_callback）
            callback_url = task.callback_url
            logger.info(f"[回调调度] 原始callback_url: {callback_url}")

            if not callback_url.startswith('http'):
                # 如果是相对路径，构建完整URL
                from system.config import get_server_port
                callback_url = f"http://localhost:{get_server_port('api_server')}/tool_result_callback"
                logger.info(f"[回调调度] 相对路径，构建完整URL: {callback_url}")

            # 确保callback_url包含路径，如果没有则添加默认路径
            # 检查URL格式: http://host:port (只有2个斜杠) 或 http://host:port/ (以斜杠结尾)
            if callback_url.count('/') == 2 or callback_url.endswith('/'):
                logger.info(f"[回调调度] URL缺少路径，添加/tool_result_callback")
                callback_url = callback_url.rstrip('/') + '/tool_result_callback'

            logger.info(f"[回调调度] 最终使用回调URL: {callback_url}, payload大小: {len(str(payload))}字节")

            # 重试机制：尝试3次，每次间隔0.5秒
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    logger.info(f"[回调调度] 发送POST请求 (尝试 {attempt + 1}/{max_retries})...")
                    # 增加超时时间到120秒，避免长时间工具（如应用启动）超时
                    async with aiohttp.ClientSession() as session:
                        async with session.post(callback_url, json=payload, timeout=aiohttp.ClientTimeout(total=120)) as response:
                            logger.info(f"[回调调度] 收到响应状态码: {response.status}")
                            if response.status == 200:
                                logger.info(f"[回调调度] 工具结果回调成功: {task.id}")
                                return
                            else:
                                # 读取响应内容以帮助调试
                                response_text = await response.text()
                                logger.warning(f"[回调调度] 工具结果回调失败 (尝试 {attempt + 1}/{max_retries}): 状态码={response.status}, 响应={response_text[:200]}")
                                if attempt < max_retries - 1:
                                    await asyncio.sleep(0.5)
                except asyncio.TimeoutError:
                    logger.warning(f"[回调调度] 工具结果回调超时 (尝试 {attempt + 1}/{max_retries})")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(0.5)
                except Exception as e:
                    logger.warning(f"[回调调度] 工具结果回调异常 (尝试 {attempt + 1}/{max_retries}): {e}")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(0.5)

            logger.error(f"[回调调度] 工具结果回调失败，已重试{max_retries}次: {task.id}")
        except Exception as e:
            logger.error(f"[回调调度] 回调通知失败: {e}")
    
    async def _execute_single_tool_call(self, tool_call: Dict[str, Any]) -> Dict[str, Any]:
        """执行单个工具调用（集成工具优先级系统）"""
        try:
            service_name = tool_call.get("service_name", "")
            tool_name = tool_call.get("tool_name", "")
            
            # 修正参数处理：保留所有非标准字段作为参数
            args = {}
            for key, value in tool_call.items():
                if key not in ["agentType", "service_name", "tool_name"]:
                    args[key] = value
            
            logger.info(f"执行工具调用: {service_name}.{tool_name} with args: {args}")
            
            # 检查是否启用工具优先级系统
            if config.tool_priority.enabled:
                try:
                    from system.tool_priority_manager import get_tool_priority_manager
                    
                    priority_manager = get_tool_priority_manager()
                    
                    # 使用工具优先级管理器调用（支持自动降级）
                    result = await priority_manager.call_tool_with_fallback(
                        tool_call, 
                        self.mcp_manager, 
                        primary_tool=tool_name
                    )
                    
                    if result.success:
                        logger.info(f"[ToolPriority] 工具调用成功: {result.tool_name} (尝试次数: {result.attempt_count}, 使用降级: {result.fallback_used})")
                        return {
                            "tool": result.tool_name,
                            "success": True,
                            "result": result.result,
                            "timestamp": datetime.utcnow().isoformat() + "Z",
                            "fallback_used": result.fallback_used,
                            "attempt_count": result.attempt_count
                        }
                    else:
                        logger.warning(f"[ToolPriority] 工具调用失败: {result.tool_name} - {result.error}")
                        return {
                            "tool": result.tool_name,
                            "success": False,
                            "error": result.error,
                            "result": result.result,
                            "timestamp": datetime.utcnow().isoformat() + "Z",
                            "fallback_used": result.fallback_used,
                            "attempt_count": result.attempt_count
                        }
                        
                except Exception as e:
                    logger.error(f"[ToolPriority] 优先级管理器调用失败，回退到标准调用: {e}")
                    # 回退到标准调用
            
            # 标准调用逻辑（不使用优先级系统）
            if self.mcp_manager and service_name and tool_name:
                result = await self.mcp_manager.unified_call(service_name, tool_name, args)
                return {
                    "tool": tool_name or "unknown",
                    "success": True,
                    "result": result,
                    "timestamp": datetime.utcnow().isoformat() + "Z"
                }
        except Exception as e:
            logger.error(f"工具调用失败: {e}")
        # 回退：最小占位实现
        await asyncio.sleep(0.05)
        return {
            "tool": tool_call.get("tool_name", "unknown"),
            "success": True,
            "result": f"已提交调用: {tool_call.get('tool_name', 'unknown')}",
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
    
    async def schedule_task(self, task_info: Dict[str, Any]) -> Dict[str, Any]:
        """调度任务"""
        try:
            skip_callback = task_info.get("skip_callback", False)

            # 创建任务对象
            task = MCPTask(
                id=task_info["id"],
                query=task_info["query"],
                tool_calls=task_info["tool_calls"],
                session_id=task_info.get("session_id"),
                request_id=task_info.get("request_id"),
                callback_url=task_info.get("callback_url"),
                created_at=task_info["created_at"]
            )

            # 添加到活跃任务
            self.active_tasks[task.id] = task

            # 加入队列
            await self.task_queue.put(task)

            # 如果是同步模式（skip_callback=True），等待任务完成
            if skip_callback:
                logger.info(f"[MCP调度] 同步等待任务完成: {task.id}")
                # 等待任务完成，最多等待60秒
                try:
                    for _ in range(60):  # 60秒超时
                        await asyncio.sleep(1)
                        if task.status in ["completed", "failed"]:
                            logger.info(f"[MCP调度] 任务完成: {task.id}, status={task.status}")
                            return {
                                "success": task.status == "completed",
                                "message": f"任务执行完成: {task.status}",
                                "task_id": task.id,
                                "result": task.result if task.status == "completed" else None,
                                "error": task.error if task.status == "failed" else None
                            }
                    # 超时
                    logger.warning(f"[MCP调度] 任务执行超时: {task.id}")
                    return {
                        "success": False,
                        "message": "任务执行超时",
                        "task_id": task.id,
                        "error": "执行超时（60秒）"
                    }
                except Exception as e:
                    logger.error(f"[MCP调度] 同步等待异常: {e}")
                    return {
                        "success": False,
                        "message": f"任务等待异常: {str(e)}",
                        "task_id": task.id,
                        "error": str(e)
                    }
            else:
                # 异步模式，立即返回
                return {
                    "success": True,
                    "message": "任务已加入调度队列",
                    "task_id": task.id
                }

        except Exception as e:
            logger.error(f"任务调度失败: {e}")
            return {
                "success": False,
                "error": str(e),
                "message": f"任务调度失败: {str(e)}"
            }
    
    async def check_duplicate(self, query: str, tool_calls: List[Dict[str, Any]]) -> Tuple[bool, Optional[str]]:
        """检查任务重复"""
        # 简单的重复检查逻辑
        for task_id, task in self.active_tasks.items():
            if (task.query == query and 
                len(task.tool_calls) == len(tool_calls) and
                all(tc.get("tool_name") == tc2.get("tool_name") 
                    for tc, tc2 in zip(task.tool_calls, tool_calls))):
                return True, task_id
        
        return False, None
    
    async def cancel_task(self, task_id: str) -> bool:
        """取消任务"""
        if task_id in self.active_tasks:
            task = self.active_tasks[task_id]
            task.status = "cancelled"
            task.completed_at = datetime.utcnow().isoformat() + "Z"
            
            # 移动到已完成任务
            del self.active_tasks[task_id]
            self.completed_tasks[task_id] = task
            
            return True
        
        return False
    
    async def get_status(self) -> Dict[str, Any]:
        """获取调度器状态"""
        return {
            "active_tasks": len(self.active_tasks),
            "completed_tasks": len(self.completed_tasks),
            "queue_size": self.task_queue.qsize(),
            "max_concurrent": self.max_concurrent,
            "workers": len(self.worker_tasks)
        }
    
    async def shutdown(self):
        """关闭调度器"""
        logger.info("MCP调度器关闭中...")
        
        # 设置关闭信号
        self.shutdown_event.set()
        
        # 等待工作线程完成
        if self.worker_tasks:
            await asyncio.gather(*self.worker_tasks, return_exceptions=True)
        
        logger.info("MCP调度器已关闭")
